---
filename: generated-app-explained.md
layout: docs
title:  "Generated app explained"
---
# Generated app explained

Once you have tried out the generated app, now it's time to understand its sources.

## Intro

First let's have a look at the lines of code:
{% highlight console %}
$ cloc .
      10 text files.
      10 unique files.
       2 files ignored.

http://cloc.sourceforge.net v 1.55  T=0.5 s (16.0 files/s, 278.0 lines/s)
-------------------------------------------------------------------------------
Language                     files          blank        comment           code
-------------------------------------------------------------------------------
Java                             5             14              7             73
XML                              2              3              0             35
YAML                             1              0              0              7
-------------------------------------------------------------------------------
SUM:                             8             17              7            115
-------------------------------------------------------------------------------
{% endhighlight %}

As you can see the generated code is minimal, and shouldn't be too difficult to understand as you will see below.

## Resource definition

The resource definition is done in the class `<your.main.package>.rest.HelloResource`:
{% highlight java %}
@Component @RestxResource
public class HelloResource {
    @GET("/message")
    public Message sayHello(String who) {
        return new Message().setMessage(String.format(
                "hello %s, it's %s",
                who, DateTime.now().toString("HH:mm:ss")));
    }
}
{% endhighlight %}

Let's decompose its content:

The `@Component` annotation declares this class as an injectable component, and the `@RestxResource` declares it as a resource.

<div class="note">
	<p>To get more information on RESTX dependency injection mechanism, check <a href="ref-factory.html">RESTX Factory reference documentation</a>.</p>
</div>

Then the sole method defines a resource endpoint thanks to its `@GET` annotation (similar annotations are available for other HTTP verbs). The parameter `"/message"` tells that this endpoint is mounted on /message relative to RESTX base path (`/api` in this case, this is defined in the `web.xml`).

The parameter `String who` defines a query parameter (a parameter that will be provided after the `?` in the URL).

The content of the method is called when a matching request is received, and constructs a `Message` object and returns it, using [joda time](http://joda-time.sourceforge.net/) to get current date / time.

You can set a breakpoint in this method and run your app in debug to see when this is called. You can also use the `open call hierarchy` action of your IDE to see the caller of the method. Here is the generated code:

{% highlight java %}
new StdEntityRoute("default#HelloResource#sayHello", mapper, new StdRouteMatcher("GET", "/message")) {
            @Override
            protected Optional<?> doRoute(RestxRequest request, RestxRouteMatch match) throws IOException {
                securityManager.check(request, isAuthenticated());
                return Optional.of(resource.sayHello(
                        /* [QUERY] who */ checkPresent(request.getQueryParam("who"), "query param who is required")
                ));
            }
}
{% endhighlight %}

As you can see the code generated by annotation processing is not too complex, you could even write it manually if you would like.

<div class="note">
	<p>Writing routes manually is definitely possible, though most of the time using annotation processing is fine, it's good to know that you can always fall back to a more low level code. All you need to do for that is declare a component implementing the <a href="https://github.com/restx/restx/blob/master/restx-core/src/main/java/restx/RestxRoute.java?source=c">RestxRoute</a> interface.</p>
</div>

<div class="note">
	<p>To get more information on RESTX REST endpoint definitions, check <a href="ref-core.html">RESTX REST endpoints reference documentation</a>.</p>
</div>


## Domain class: Message

The `Message` class is part of the application domain (it's also called an entity): 

{% highlight java %}
public class Message {
    private String message;

    public String getMessage() {
        return message;
    }

    public Message setMessage(String message) {
        this.message = message;
        return this;
    }

    @Override
    public String toString() {
        return "Message{" +
                "message='" + message + '\'' +
                '}';
    }
}
{% endhighlight %}

This is a plain Java bean: the `toString` method is not mandatory, and using fluent setter (which returns `this`) is not mandatory either.

<div class="note">
	<p>Binding to JSON is done using the <a href="http://wiki.fasterxml.com/JacksonHome">jackson library</a>, check theirs docs to see how to configure JSON mapping.</p>
	<p>You can also use Bean Validation (JSR 303) / <a href="http://www.hibernate.org/subprojects/validator.html">Hibernate Validator</a> annotations to add validation to your beans.</p>
</div>

## Resource Spec

What is called a spec in RESTX is a yaml file describing a resource behaviour, or a set of behaviours chained in a scenario.

In the generated app, you can check the `should_say_hello.spec.yaml` file in `src/test/resources/specs/hello`:
{% highlight yaml %}
title: should say hello
given:
  - time: 2013-03-31T14:33:18.272+02:00
wts:
  - when: GET message?who=xavier
    then: |
      {"message":"hello xavier, it's 14:33:18"}
{% endhighlight %}

The notation follows BDD terminology `given` `when` `then` (`wts` stands for When ThenS).

In the given section the state of the system before the HTTP requests is described. In this case we only specify the time in ISO format.
Then a list of `when` `then` pairs follows, the `when` specify HTTP request, the `then` HTTP response.

This spec is used for 2 things:

- example in the API docs
- integration test


<div class="note">
	<p>Because RESTX app follows REST principles, the server has no conversation state. Therefore any HTTP request can be tested in isolation.</p>
	<p>The principle of scenario is there mainly to avoid repeating the `given` part too frequently, or also to be able to verify that the system state change after an HTTP request, for example issue a `GET` after a `PUT` to verify that the new resource representation has been stored.</p>
</div>

<div class="note">
	<p>To get more information on RESTX spec concept and related features, check <a href="ref-specs.html">RESTX Specs reference documentation</a>.</p>
</div>

## Resource Spec Test

To actually be able to run this spec as a test, it is necessary to write a JUnit test to run it:
{% highlight java %}
public class HelloResourceSpecTest {
    @ClassRule
    public static RestxSpecRule rule = new RestxSpecRule(
            AppServer.WEB_INF_LOCATION,
            AppServer.WEB_APP_LOCATION);

    @Test
    public void should_say_hello() throws Exception {
        rule.runTest("specs/hello/should_say_hello.spec.yaml");
    }
}
{% endhighlight %}

As you can see this code is very basic thanks to junit rule power, it merely tells basic information to start the server and to run the spec.

<div class="note">
	<p>To get more information on RESTX spec concept and related features, check <a href="ref-specs.html">RESTX Specs reference documentation</a>.</p>
</div>

## AppServer

The `AppServer` class is the class used to run the app as a standard Java app. 
{% highlight java %}
public class AppServer {
    public static final String WEB_INF_LOCATION = "src/main/webapp/WEB-INF/web.xml";
    public static final String WEB_APP_LOCATION = "src/main/webapp";

    public static void main(String[] args) throws Exception {
        int port = Integer.valueOf(Optional.fromNullable(System.getenv("PORT")).or("8080"));
        WebServer server = new JettyWebServer(WEB_INF_LOCATION, WEB_APP_LOCATION, port, "0.0.0.0");
        System.setProperty("restx.baseUri", server.baseUrl() + "/api");
        server.startAndAwait();
    }
}
{% endhighlight %}

All it does is launch an embedded server (Jetty in this particular case, but Tomcat and SimpleFramework server are also supported).

<div class="note">
	<p>If you prefer to run your JavaEE web container of choice separately and use standard deploy mechanism, no problem, the generated app is already configured to be packaged as a standard war.</p>
</div>

## AppModule

The `AppModule` class is defined like this:
{% highlight java %}
@Module
public class AppModule {
    @Provides
    public SignatureKey signatureKey() {
         return new SignatureKey("4f768f23-703e-4268-9e9e-51d2e052b6a1 4082747839477764571 MyApp myapp".getBytes(Charsets.UTF_8));
    }
    @Provides
    @Named("restx.admin.password")
    public String restxAdminPassword() {
        return "qwerty";
    }
    @Provides
    @Named("app.name")
    public String appName() {
        return "MyApp";
    }
}
{% endhighlight %}

This class is mandatory to provide at least a `SignatureKey` used to sign content sent to the clients. The string is used as salt, it can be any content, but make sure to keep it private.

The `@Module` annotation indicates that this class is used as a RESTX module, able to define a set of components.

The `@Provides` annotation on the `signatureKey` method is a way to define a component instanciation programmatically. This kind of method can take arbitrary parameters, injected by the RESTX factory.

<div class="note">
	<p>To get more information on RESTX dependency injection mechanism, check <a href="ref-factory.html">RESTX Factory reference documentation</a>.</p>
</div>

In the `AppModule`, you will be able to define lots of Application scoped objects, such as :
 - An admin password, which will be used to authenticate on the ` RESTX Administration Console`
 - An application name, which will be used in different ways, particularly by suffixing RESTX `Cookies names`

## logback.xml

This file is used to configure logging:

{% highlight xml %}
<configuration>
    <appender name="FILE" class="ch.qos.logback.core.FileAppender">
        <file>app.log</file>
        <encoder>
            <pattern>%d{HH:mm:ss.SSS} [%-17thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>
    <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%d{HH:mm:ss.SSS} [%-17thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>

    <logger name="org.eclipse.jetty.server.AbstractConnector" level="WARN" />
    <logger name="org.eclipse.jetty.server.handler.ContextHandler" level="WARN" />
    <logger name="org.hibernate.validator.internal.engine.ConfigurationImpl" level="WARN" />
    <logger name="restx.factory.Factory" level="WARN" />

    <root level="info">
        <appender-ref ref="FILE"/>
        <appender-ref ref="STDOUT"/>
    </root>
</configuration>
{% endhighlight %}

## web.xml

This file is the standard JavaEE web descriptor. It's used to configure the RESTX servlet:

{% highlight xml %}
<web-app xmlns="http://java.sun.com/xml/ns/javaee"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
      version="3.0" metadata-complete="true">
    <servlet>
        <servlet-name>restx</servlet-name>
        <servlet-class>restx.servlet.RestxMainRouterServlet</servlet-class>
        <load-on-startup>1</load-on-startup>
    </servlet>
    <servlet-mapping>
        <servlet-name>restx</servlet-name>
        <url-pattern>/api/*</url-pattern>
    </servlet-mapping>
</web-app>
{% endhighlight %}

<div class="note">
	<p>This file is not needed if you use SimpleFramework integration rather than JavaEE web container.</p>
</div>

## RESTX module descriptor

RESTX uses its own module descriptor format, which is build tool agnostic. The file is called `md.restx.json`:

{% highlight json %}
{
    "module": "myapp:myapp:0.1-SNAPSHOT",
    "packaging": "war",
    "properties": {
        "java.version": "1.7",
        "restx.version": "0.2.5-SNAPSHOT"
    },
    "dependencies": {
        "compile": [
            "io.restx:restx-core:${restx.version}",
            "io.restx:restx-core-annotation-processor:${restx.version}",
            "io.restx:restx-factory:${restx.version}",
            "io.restx:restx-factory-admin:${restx.version}",
            "io.restx:restx-monitor-admin:${restx.version}",
            "io.restx:restx-server-jetty:${restx.version}",
            "io.restx:restx-apidocs:${restx.version}",
            "io.restx:restx-specs-admin:${restx.version}",
            "ch.qos.logback:logback-classic:1.0.9"
        ],
        "test": [
            "io.restx:restx-specs-tests:${restx.version}",
            "junit:junit:4.11"
        ]
    }
}
{% endhighlight %}

This file is used at build time only, its the source used by RESTX to:

- generate Maven POM or Ivy files
- manage app dependencies ([soon, watch issue if interested](https://github.com/restx/restx/issues/5))

<div class="note">
	<p>It isn't used at runtime, you can get rid of it if you prefer to manage building, running and deploying your app on your own.</p>
</div>

The file format is pretty straightforward to understand if you are familiar with Maven, Ivy or similar build / dependency management tools.

<div class="go-next">
	<ul>
		<li><a href="ref-core.html"><i class="icon-beer"> </i> REST support reference</a></li>
		<li><a href="ref-factory.html"><i class="icon-beer"> </i> RESTX Factory reference</a></li>
		<li><a href="/community/"><i class="icon-beer"> </i> Community</a></li>
		<li><a href="/docs/"><i class="icon-book"> </i> Documentation</a></li>
	</ul>	
</div>

